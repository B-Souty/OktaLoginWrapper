__appname__ = 'OktaLoginWrapper'
__author__ = 'B-Souty'

from lxml import html, etree
from base64 import b64decode
from getpass import getpass
import requests
import json
import time


class OktaSession(object):
    """An Okta session

    Provide an Okta session with the proper cookies to login to apps.

    Attributes:
        organization (str): Okta instance name.
        okta_session (:obj:`requests.session`): Session object with Okta cookies.
        _session_token (str): SAML session token.
        _user_id (str): Okta user_id.
    """

    def __init__(self, organization):
        """__init__ method.

        Args:
            organization (str): okta instance name (<organization>.okta.com).
        """
        self.organization = str(organization).lower()
        self.okta_session = requests.session()
        self.okta_session.headers.update({
            'Accept': "application/json",
            'Content-Type': "application/json",
            'Cache-Control': "no-cache",
        })
        self._session_token = None
        self._user_id = None

    def okta_auth(self, username, password, factor_type='push', answer=None, passCode=None):
        """Initiate connection to Okta instance

        Args:
            username (str): Okta username.
            password (str): Okta password.
            factor_type (str): Multi-Factor type (default 'push')
            answer (str): answer to the secret question (default: None)
            passCode (str): OTP generated by hardware/software token (default:None)

        Calls:
            _okta_verify() with auth_params and factor_type as arguments
            if username/password are correct.
        """
        if answer:
            factor_type = 'question'
        if passCode:
            factor_type = 'token'
        url_authn = 'https://{}.okta.com/api/v1/authn'.format(self.organization)
        payload_authn = json.dumps({
            "username": username,
            "password": password,
            "options": {"warnBeforePasswordExpired": True,
                        "multiOptionalFactorEnroll": True},
        })
        response = self.okta_session.post(url_authn, data=payload_authn)

        if response.json().get('status') == "SUCCESS":
            self._session_token = response.json().get('sessionToken')
            self._user_id = response.json().get('_embedded').get('user').get('id')
            self._cookie_brewer()
            return "Successfully logged in."

        factors = json.loads(response.text).get('_embedded').get('factors')
        auth_params = {
            'stateToken': json.loads(response.text).get('stateToken'),
            'factor_id': [i['id'] for i in factors if factor_type in i.get('factorType')][0],
            'provider': 'OKTA',
            'answer': answer,
            'passCode': passCode,
        }
        factor_type = [i['factorType'] for i in factors if i['id'] == auth_params['factor_id']][0]
        return self._okta_verify(auth_params, factor_type)

    def _okta_verify(self, auth_params, factor_type):
        """Request 2nd factor authentication

        Args:
            auth_params (dict): {
                stateToken (str): token generated during authentication
                factor_id (str): factor_id used for 2nd factor
                provider (str): just OKTA
                answer (str): answer to the secret question
                passCode (str): token generated OTP
            }
            factor_type (str): type of MFA to use

        Returns:
            The Okta session is updated with the required cookies for future connection.
        """
        url_push = "https://{}.okta.com/api/v1/authn/factors/{}/verify".format(self.organization, auth_params['factor_id'])
        response = self.okta_session.post(url_push, data=json.dumps(auth_params))
        mfa_state = json.loads(response.text).get('status')

        if factor_type == 'push':
            timeout = time.time() + 60
            while mfa_state != 'SUCCESS':
                timer = int(timeout - time.time())
                if timer <= 0:
                    self.okta_session.close()
                    return "Connection timed out."
                print("{} seconds remaining before timeout.".format(timer))
                time.sleep(2)
                response = self.okta_session.post(url_push, data=json.dumps(auth_params))
                mfa_state = json.loads(response.text).get('status')
                if json.loads(response.text).get('factorResult') == 'REJECTED':
                    self.okta_session.close()
                    return "You rejected the connection, closing the session."

        if factor_type == 'question':
            while mfa_state != 'SUCCESS':
                secret_question = json.loads(response.text).get('_embedded').get('factor').get('profile').get('questionText')
                answer = input(secret_question)
                auth_params.update({'answer': answer})
                response = self.okta_session.post(url_push, data=json.dumps(auth_params))
                mfa_state = json.loads(response.text).get('status')

        if 'token' in factor_type:
            while mfa_state != 'SUCCESS':
                passCode = str(input('Please type in your OTP: '))
                auth_params.update({'passCode': passCode})
                response = self.okta_session.post(url_push, data=json.dumps(auth_params))
                mfa_state = json.loads(response.text).get('status')

        self._session_token = json.loads(response.text).get('sessionToken')
        self._user_id = json.loads(response.text).get('_embedded').get('user').get('id')
        self._cookie_brewer()
        return "You are now logged in."

    def _cookie_brewer(self):
        cookie_brewer_url = 'https://{0}.okta.com/login/sessionCookieRedirect?checkAccountSetupComplete=true&token={1}&redirectUrl=https%3A%2F%2F{0}.okta.com%2Fuser%2Fnotifications'.format(self.organization, self._session_token)
        self.okta_session.get(url=cookie_brewer_url)

    def app_list(self):
        """Return a list of apps assigned to the logged in user."""
        appslist_url = "https://{}.okta.com/api/v1/users/{}/appLinks/".format(self.organization, self._user_id)
        appslist_headers = {
            "Host": "{}.okta.com".format(self.organization),
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
            "Accept-Encoding": "gzip, deflate, br",
            "Accept-Language": "en-US,en;q=0.9,fr;q=0.8,nl;q=0.7",
        }

        return self.okta_session.get(url=appslist_url, headers=appslist_headers).json()

    def connect_to(self, url_app):
        """Connect to an assigned app.

        Args:
            url_app (str): the "Embed Link" of an okta app assigned to the logged in user

        Returns:
            requests.models.Response object of the homepage of the app you're connecting to.
        """
        response = self.okta_session.get(url=url_app)
        tree = html.fromstring(response.text)
        saml_response = tree.xpath('//input[@name="SAMLResponse"]')[0].attrib.get('value')
        url_saml = etree.XML(b64decode(saml_response)).get('Destination')
        payload_saml = {
            "SAMLResponse": saml_response,
            "RelayState": "",
        }
        headers_saml = {
            'origin': "https://{}.okta.com".format(self.organization),
            'upgrade-insecure-requests': "1",
            'content-type': "application/x-www-form-urlencoded",
            'accept': "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
            'accept-encoding': "gzip, deflate, br",
            'accept-language': "en-US,en;q=0.9,fr;q=0.8,nl;q=0.7",
            'cache-control': "no-cache",
        }
        return self.okta_session.post(url=url_saml, data=payload_saml, headers=headers_saml)

    def connect_from_appslist(self):
        """Provide an nteractive way to connect to an app"""
        app_name = input('app name: ').lower()
        results = [{'name': i.get('label'), 'link': i.get('linkUrl')} for i in self.app_list() if app_name in i.get('label').lower()]
        for ind, app in enumerate(results):
            print("{} - {}".format(ind, app.get('name')))
        choice = int(input('Please select the app to connect to: '))
        app_link = results[choice].get('link')
        return self.connect_to(app_link)


if __name__ == '__main__':

    my_session = OktaSession(input('Please type your organization name (<organization>.okta.com): '))
    my_session.okta_auth(
        username=input('Type in your Okta username: '),
        password=getpass('Okta password: '),
        factor_type=input('Factor selection: ') or 'push'
    )
    my_app = my_session.connect_from_appslist()
    print(my_app.content)
    my_session.okta_session.close()
